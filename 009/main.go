package main

import (
	"bufio"
	"fmt"
	"io"
	"log"
	"os"
)

// Большой ручей преграждает вам путь. По словам местных жителей, сейчас переходить ручей небезопасно, потому что он завален мусором. Вы смотрите вниз на ручей, а там не вода, а большой поток символов.

// Вы сидите какое-то время и записываете часть потока (они находятся по кнопке Данные внизу задачи). Символы представляют собой группы — некие последовательности, которые начинаются с символа { и заканчиваются на символ }. Внутри каждой группы есть ноль или более других вещей, разделенных запятыми: это либо другая группа, либо мусор. Поскольку группы могут содержать другие группы, символ } закрывает только самую последнюю незакрытую группу, то есть группы могут быть вложенными. Данные этой задачи в файле (по кнопке Данные) представляет собой одну большую группу, которая сама содержит множество маленьких групп.

// Иногда вместо группы вы найдете мусор. Мусор начинается с < и заканчивается >. Между этими угловыми скобками может стоять практически любой символ, включая { и }. Внутри мусора < не имеет особого значения.

// В тщетной попытке очистить мусор, какая-то программа использовала ! и отменила некоторые из символов внутри себя. Внутри мусора любой символ, который идет после ! следует игнорировать, в том числе <, > и даже еще один !.

// В файле нет больше никаких других символов, которые не соответствуют этим правилам. Вне мусора вы найдете только правильно сформированные группы, а мусор всегда завершается в соответствии с приведенными выше правилами.

// Ваша цель — найти общий балл для всех групп. Каждой группе присваивается балл, который на единицу больше, чем балл группы, в которую она непосредственно входит. (То есть самая дальняя от середины группа получает 1 балл, а самая вложенная - наибольший балл.)

// Каков общий балл для всех групп в вашем вводе?

func main() {
	f, err := os.OpenFile("009/09.txt", os.O_RDONLY, 0644)
	if err != nil {
		fmt.Println("file not found")
		log.Fatalln(err)
	}
	defer f.Close()

	fmt.Println(run(f))

}

func run(r io.Reader) int {

	reader := bufio.NewReader(r)
	res := 0
	counter := 0
	b, err := reader.ReadByte()
	trash := false
	prevB := b

	for ; err != io.EOF; b, err = reader.ReadByte() {
		if err != nil {
			log.Fatalln(err)
		}
		if trash {
			if b == '>' && prevB != '!' {
				trash = false
			}
			if b == '!' && prevB == '!' {
				prevB = ' '
				continue
			}
			prevB = b
			continue
		}
		if b == '<' {
			trash = true
			continue
		}
		if b == '{' {
			counter++
			continue
		}
		if b == '}' {
			res += counter
			counter--
			continue
		}
	}
	return res
}
