package main

import (
	"bufio"
	"fmt"
	"io"
	"log"
	"os"
	"regexp"
	"sort"
	"strings"
	"time"
)

// Вам нужно проникнуть внутрь кладовки и исправить проблемы с костюмом, но за пределами лаборатории стоит охранник. Когда вы ищете в шкафу рядом что-нибудь, что может помочь, вы обнаруживаете, что вы не первый человек, который хочет проникнуть внутрь. Кто-то, закрывая стены, провел час, начиная каждую полночь в течение последних нескольких месяцев, тайно наблюдая за этим постом охраны! Они записывали удостоверение личности одного охранника, дежурившего в ту ночь, а также когда они засыпали или просыпались на своем посту (Ваши данные вы можете взять по кнопке Данные внизу задачи.

// Например, рассмотрим следующие записи, которые уже упорядочены в хронологическом порядке:
// [1518-11-01 00:00] Охранник №10 начинает смену
// [1518-11-01 00:05] засыпает
// [1518-11-01 00:25] просыпается
// [1518-11-01 00:30] засыпает
// [1518-11-01 00:55] просыпается
// [1518-11-01 23:58] Охранник №99 начинает смену
// [1518-11-02 00:40] засыпает
// [1518-11-02 00:50] просыпается
// [1518-11-03 00:05] Охранник №10 начинает смену
// [1518-11-03 00:24] засыпает
// [1518-11-03 00:29] просыпается
// [1518-11-04 00:02] Охранник №99 начинает смену
// [1518-11-04 00:36] засыпает
// [1518-11-04 00:46] просыпается
// [1518-11-05 00:03] Охранник №99 начинает смену
// [1518-11-05 00:45] засыпает
// [1518-11-05 00:55] просыпается

// Временные метки записываются в формате год-месяц-день час:минута. Засыпающий или просыпающийся охранник всегда тот, чья смена началась последней. Поскольку все время сна/бодрствования приходится на полночный час (00:00–00:59), для этих событий важна только минутная часть (00–59).

// Визуально эти записи показывают, что охранники №10 и №99 спят в это время:
// Дата	ID	Минуты
//           	1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60
// 11-01	№10 . . . . # # # # # #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  .  .  .  .  .  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  .  .  .  .  .  .
// 11-02 	№99 . . . . . . . . . .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  #  #  #  #  #  #  #  #  #  #  .  .  .  .  .  .  .  .  .  .  .
// 11-03 	№10 . . . . . . . . . .  .  .  .  .  .  .  .  .  .  .  .  .  .  #  #  #  #  #  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .
// 11-04 	№99 . . . . . . . . . .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  #  #  #  #  #  #  #  #  #  #  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .
// 11-05 	№99 . . . . . . . . . .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  #  #  #  #  #  #  #  #  #  #  .  .  .  .  .  .

// Столбцы:
// Дата, которая показывает часть месяца и дня соответствующего дня;
// ID личности, на котором указан дежурный в этот день охранник;
// Минуты, показывающая минуты, в течение которых охранник спал в течение полуночи. (Заголовок столбца «Минуты» показывает цифру единиц во второй строке.)
// Бодрствование отображается как ., а сон отображается как #.
// Обратите внимание, что охранники считаются спящими в ту минуту, когда они засыпают, и они считаются бодрствующими в ту минуту, когда они просыпаются. Например, поскольку охранник № 10 просыпается в 00:25 1518-11-01, 25-я минута помечается как бодрствование.

// Кто из всех охранников чаще всего спит в одну и ту же минуту?
// В приведенном выше примере охранник № 99 проспал 45-ю минуту больше, чем другой охранник, или минуту - всего три раза. (Во всех остальных случаях другой охранник проспал каждую минуту не более двух раз.)

// Каков ID выбранного вами охранника, умноженный на выбранную вами минуту? (В приведенном выше примере ответ будет 99 * 45 = 4455.)

type worktime struct {
	datatime    time.Time
	description string
}

func main() {
	f, err := os.OpenFile("005/05.txt", os.O_RDONLY, 0644)
	if err != nil {
		fmt.Println("file not found")
		log.Fatalln(err)
	}
	defer f.Close()
	wt := parse(f)
	fmt.Println(check(wt))
}

var re = regexp.MustCompile(
	`\[([\d]{4}-[\d]{2}-[\d]{2}\s[\d]{2}:[\d]{2})]\s([#\w\s\d]*)`,
)

func parse(r io.Reader) []worktime {
	m := make([]worktime, 0)
	reader := bufio.NewReader(r)
	line, _, err := reader.ReadLine()
	for ; err != io.EOF; line, _, err = reader.ReadLine() {
		if err != nil {
			fmt.Println("can not read file")
			log.Fatalln(err)
		}
		b := re.FindAllSubmatch(line, -1)
		wt := worktime{}
		if wt.datatime, err = time.Parse("2006-01-02 15:04", string(b[0][1])); err != nil {
			log.Fatalln(err)
		}
		wt.description = string(b[0][2])
		m = append(m, wt)
	}

	sort.Slice(m, func(i, j int) bool {
		return m[i].datatime.Before(m[j].datatime)
	})

	return m
}

func check(wt []worktime) int {
	m := make(map[int][]int, 0)
	var s, f, g int
	for _, v := range wt {
		switch v.description {
		case "falls asleep":
			s = v.datatime.Minute()
		case "wakes up":
			f = v.datatime.Minute()
			for i := s; i < f; i++ {
				m[g][i]++
			}
		default:
			var n int
			fmt.Fscanf(strings.NewReader(v.description), "Guard #%d", &n)
			if _, ok := m[n]; !ok {
				m[n] = make([]int, 60)
			}
			g = n
		}
	}
	k, i := maxInMap(m)

	return k * i
}

func maxInMap(m map[int][]int) (int, int) {
	var guard, max, idx int
	for g, v := range m {
		index, val := maxInSlice(v)
		if max < val {
			guard, idx, max = g, index, val
		}
	}
	return guard, idx
}

func maxInSlice(a []int) (index, value int) {
	value = a[0]
	for i, v := range a {
		if value < v {
			index, value = i, v
		}
	}
	return
}
